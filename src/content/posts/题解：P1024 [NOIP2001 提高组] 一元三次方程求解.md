---
title: 题解：P1024 [NOIP2001 提高组] 一元三次方程求解
# 文章标题(必需)
published: 2025-12-09
# 文章发布日期，格式为YYYY-MM-DD
pinned: false
# 是否置顶文章，true表示置顶
description: 一道关于一元三次方程的的二分题解
# 文章描述(必需)
tags: [算法, 刷题]
# 文章标签数组，用于标记文章主题
  # 分类 1：计算机基础 → Tags 选项
      # 操作系统相关：进程 / 线程、Linux 命令、内存管理、死锁、PV 操作、操作系统实验
      # 计算机网络相关：TCP/IP、HTTP/HTTPS、Socket 编程、Wireshark 抓包、子网划分
      # 数据库相关：SQL 语法、MySQL 基础、事务 ACID、索引、ER 图、数据库实验
      # 组成原理相关：CPU 架构、Cache 缓存、指令系统、IO 接口
  # 分类 2：编程语言 → Tags 选项
      # Python 相关：Python 基础、Pandas、requests、matplotlib、Django、Flask、正则表达式
      # Java 相关：Java 语法、SpringBoot、MyBatis、Maven、ArrayList/HashMap
      # C/C++ 相关：C 语言指针、C++ 类与对象、STL 容器、Linux 下 C 编程、内存泄漏
      # JavaScript 相关：JS 基础、DOM 操作、Axios、ES6 语法、Vue 基础（若侧重 JS + 前端）
  # 分类 3：开发方向尝试 → Tags 选项
      # 前端相关：HTML/CSS、Vue3、React、Pinia、Element UI、响应式布局、前端调试
      # 后端相关：SpringBoot、Node.js、RESTful API、MySQL、Redis、Postman、接口测试
      # 移动端相关：Flutter、Android Jetpack、Swift 基础、跨平台开发、App 调试
      # 通用开发：VSCode 插件、Git 基础（版本控制）、项目部署（本地）
  # 分类 4：算法与数据结构 → Tags 选项
      # 数据结构相关：链表、二叉树、栈 / 队列、哈希表、图（DFS/BFS）、堆
      # 算法相关：动态规划（DP）、贪心算法、二分查找、排序算法（快排 / 归并）、回溯算法
      # 刷题相关：LeetCode、蓝桥杯、ACM 入门、题解、递归、滑动窗口、两数之和（经典题）
  # 分类 5：项目记录 → Tags 选项
      # 课程项目相关：操作系统课设、数据库课设、计网课设、图书管理系统、进程调度模拟
      # 个人项目相关：Python 爬虫项目、Vue 个人博客、SpringBoot 接口项目、数据可视化（ECharts）
      # 竞赛项目相关：蓝桥杯省赛、ACM 区域赛、数学建模、挑战杯、项目部署
      # 项目细节：用户登录功能、MySQL 存储、bug 修复、界面设计、JSON 数据
  # 分类 6：我的日常 → Tags 选项
      # 学习方法：编程入门技巧、错题整理、知识点复盘、小组学习
      # 资源推荐：计算机书籍、B 站教程、VSCode 插件、GitHub 开源项目、Postman
      # 大学生活：实习准备、简历优化、技术面试、408 复习（考研）、期末复习、实验室经历
  # 分类 7：个性化（如 AI / 嵌入式） → Tags 选项
    # AI 方向：机器学习、深度学习、TensorFlow、PyTorch、线性回归、图像识别、数据集处理
    # 嵌入式方向：STM32、51 单片机、Arduino、C 语言嵌入式、传感器（温湿度）、STM32CubeMX
    # 其他方向（如大数据）：Hadoop、Spark、数据清洗、Hive
category: 算法与数据结构
# 文章分类，用于组织文章（计算机基础、编程语言、开发方向尝试、算法与数据结构、项目记录、我的日常、自己的个性化方面）
licenseName: "Unlicensed"
# 文章许可证名称
  # 常见的许可证名称：
  # "MIT"
  # "Apache-2.0"
  # "CC BY 4.0"
  # "CC BY-SA 4.0"
  # "Unlicensed"
author: qiqimora
# 文章作者姓名

# sourceLink: "https://github.com/zhangsan/vue3-guide"
# # 文章源链接，通常指向GitHub仓库或原始来源

draft: false
# 是否为草稿，true表示草稿，false表示正式发布
date: 2025-12-09
# 文章创建日期

# image:
#   url: './cover.jpg'
#   # 文章封面图片URL
#   alt: '文章封面'
#   # 文章封面图片替代文本

pubDate: 2025-12-09
# 文章发布日期(与published类似)

# encrypted: true
# # 是否加密文章，true表示加密
# password: 'qiqimora'
# # 文章加密密码
---

<!-- 管理图片和其他资源
使用这种方法，你可以将文章相关的所有资源都放在同一个文件夹中，便于管理：

src/content/posts/my-complex-post/
├── index.md
├── image1.png
├── image2.jpg
└── data.json
在文章中引用图片时，可以直接使用相对路径：

![图片描述](image1.png)
注意像这样直接填写文件的名字,这样才能让RSS正常构建图片的路径 
-->

<!-- 下面是正文 -->
# 题解：P1024 [NOIP2001 提高组] 一元三次方程求解

## 题目描述

给出一个形如 $ax^3 + bx^2 + cx + d = 0$ 的一元三次方程，系数均为实数。已知该方程在 $[-100, 100]$ 范围内存在三个不同的实根，且根与根之差的绝对值 $\ge 1$。要求从小到大输出这三个实根，精确到小数点后 2 位。

-----

## 方法一：求导分区间法（我的解法）

### 1\. 算法思路

一元三次函数 $f(x)$ 的图像通常呈“N”字形或倒“N”字形。为了找到三个根，我们需要确定函数的**单调区间**。
单调性的转折点就是函数的**极值点**。

1.  **求导**：对原函数求导得到二次函数 $f'(x) = 3ax^2 + 2bx + c$。
2.  **求极值点**：令 $f'(x) = 0$，利用求根公式 $x = \frac{-B \pm \sqrt{B^2 - 4AC}}{2A}$ 求出两个极值点 $x_1, x_2$。
      * 注意系数对应关系：$A=3a, B=2b, C=c$。
3.  **划分区间**：两个极值点将数轴（在题目范围内）划分为三个单调区间：
      * $[-100, x_1]$
      * $[x_1, x_2]$
      * $[x_2, 100]$
4.  **二分查找**：由于题目保证有三个不同的实根，根据函数的连续性和单调性，这三个区间内必然各有一个根。我们只需要在每个区间内分别进行二分查找即可。

### 2\. 代码实现

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#include <iomanip>
#include <vector>

using namespace std;

#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

typedef pair<double, double> PDD; 

double a, b, c, d;

// 计算函数值 f(x)
double f(double x) {
    return a * x * x * x + b * x * x + c * x + d;
}

int main() {

    IOS;
    
    cin >> a >> b >> c >> d;

    // 1. 求导 f'(x) = 3ax^2 + 2bx + c
    double A = 3 * a;
    double B = 2 * b;
    double C = c;
    
    // 2. 求极值点（导数为0的点）
    double delta = B * B - 4 * A * C;
    double x1 = (-B + sqrt(delta)) / (2 * A);
    double x2 = (-B - sqrt(delta)) / (2 * A);
    
    // 确保 x1 < x2
    if (x1 > x2) swap(x1, x2);

    // 3. 划分三个单调区间
    vector<PII> sections(3);
    sections[0] = {-100, x1};
    sections[1] = {x1, x2};
    sections[2] = {x2, 100};

    // 4. 在每个区间内二分查找
    for (int i = 0; i < 3; i++) {
        double l = sections[i].first;
        double r = sections[i].second;
        
        // 当区间长度大于 1e-7 时继续二分，保证精度
        while (r - l > 1e-7) {
            double mid = (l + r) / 2;
            // 零点存在定理：如果 f(mid) 和 f(l) 异号（或其中之一为0），说明根在左半边
            // 注意：这里利用 f(l) 作为参考点判断符号变化
            if (f(mid) * f(l) <= 0) {
                r = mid;
            } else {
                l = mid;
            }
        }
        // 输出结果，控制精度
        cout << fixed << setprecision(2) << l << " ";
    }
    
    return 0;
}
```

### 3\. 复杂度分析

  * **时间复杂度**：$O(K)$，其中 $K$ 是二分的次数（常数）。
  * **空间复杂度**：$O(1)$。

-----

## 方法二：暴力枚举 + 二分（答案推荐解法）

### 1\. 算法思路

利用题目给出的强力提示：**“根与根之差的绝对值 $\ge 1$”**。
这意味着，任意长度为 1 的区间 $[i, i+1]$ 内，最多只可能有一个根。

1.  **枚举**：从 $-100$ 到 $99$ 枚举每一个整数 $i$。
2.  **判断**：检查区间 $[i, i+1]$ 的左右端点函数值。
      * 如果 $f(i) = 0$，则 $i$ 是根。
      * 如果 $f(i) \cdot f(i+1) < 0$，说明根在 $(i, i+1)$ 之间。
3.  **二分**：对于确定的区间 $[i, i+1]$，进行二分查找精确求根。

### 2\. 代码片段

```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
#include <iomanip>
#include <vector>

using namespace std;

#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);

typedef pair<double, double> PDD; 

double a, b, c, d;

// 计算函数值 f(x)
double f(double x) {
    return a * x * x * x + b * x * x + c * x + d;
}

int main() {

    IOS;
    
    cin >> a >> b >> c >> d;

    for (int i = -100; i < 100; i++) {
        double y1 = f(i);
        double y2 = f(i + 1);

        if (abs(y1) < 1e-9) { // 也就是 y1 == 0
            cout << fixed << setprecision(2) << (double)i << " ";
        } 
        else if (y1 * y2 < 0) { // 区间内有根
            double l = i, r = i + 1;
            for (int k = 0; k < 100; k++) { // 二分 100 次
                double mid = (l + r) / 2;
                if (f(mid) * f(l) <= 0) r = mid;
                else l = mid;
            }
            cout << fixed << setprecision(2) << l << " ";
        }
    }
    
    return 0;
}
```

*注：这种方法避开了繁琐的求导公式，且不用处理 $a=0$ 等特殊情况，在比赛中容错率更高。*